# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11VB4ewr_FuogLrsWftnjbRJKJ4MUpSPB
"""

"""
Database Manager for Talent Match System
Handles all database connections and SQL operations
"""

import psycopg2
from psycopg2.extras import RealDictCursor, Json
import pandas as pd
import streamlit as st
from typing import List, Dict, Optional
import json


class DatabaseManager:
    """Manages database connections and queries"""

    def __init__(self):
        """Initialize database connection using Streamlit secrets"""
        try:
            self.conn_params = {
                'host': st.secrets["database"]["host"],
                'port': st.secrets["database"]["port"],
                'database': st.secrets["database"]["database"],
                'user': st.secrets["database"]["user"],
                'password': st.secrets["database"]["password"]
            }
            self._test_connection()
        except Exception as e:
            st.error(f"Database configuration error: {e}")
            raise

    def _test_connection(self):
        """Test database connection"""
        try:
            conn = self.get_connection()
            conn.close()
        except Exception as e:
            raise ConnectionError(f"Cannot connect to database: {e}")

    def get_connection(self):
        """Get database connection"""
        return psycopg2.connect(**self.conn_params)

    def execute_query(self, query: str, params: tuple = None, fetch: bool = True):
        """Execute SQL query and return results"""
        conn = self.get_connection()
        try:
            with conn.cursor(cursor_factory=RealDictCursor) as cur:
                cur.execute(query, params)

                if fetch:
                    results = cur.fetchall()
                    return pd.DataFrame(results) if results else pd.DataFrame()
                else:
                    conn.commit()
                    return cur.lastrowid if hasattr(cur, 'lastrowid') else None
        except Exception as e:
            conn.rollback()
            raise e
        finally:
            conn.close()

    # ========================================
    # HOME PAGE QUERIES
    # ========================================

    def get_total_employees(self) -> int:
        """Get total number of employees"""
        query = "SELECT COUNT(*) as count FROM employees"
        result = self.execute_query(query)
        return result['count'].iloc[0] if not result.empty else 0

    def get_high_performers_count(self) -> int:
        """Get count of high performers (rating 5)"""
        query = """
        SELECT COUNT(DISTINCT employee_id) as count
        FROM performance_yearly
        WHERE rating = 5 AND year = (SELECT MAX(year) FROM performance_yearly)
        """
        result = self.execute_query(query)
        return result['count'].iloc[0] if not result.empty else 0

    def get_total_vacancies(self) -> int:
        """Get total number of vacancies"""
        query = "SELECT COUNT(*) as count FROM talent_benchmarks"
        result = self.execute_query(query)
        return result['count'].iloc[0] if not result.empty else 0

    def get_recent_vacancies(self, limit: int = 5) -> pd.DataFrame:
        """Get recent vacancies"""
        query = f"""
        SELECT
            job_vacancy_id,
            role_name,
            job_level,
            role_purpose,
            created_at,
            ARRAY_LENGTH(selected_talent_ids, 1) as benchmark_count
        FROM talent_benchmarks
        ORDER BY created_at DESC
        LIMIT {limit}
        """
        return self.execute_query(query)

    # ========================================
    # CREATE VACANCY QUERIES
    # ========================================

    def get_high_performers(self) -> pd.DataFrame:
        """Get list of high performers for selection"""
        query = """
        SELECT DISTINCT
            e.employee_id,
            e.fullname,
            pos.name as position,
            dir.name as directorate,
            gr.name as grade
        FROM employees e
        JOIN performance_yearly p ON e.employee_id = p.employee_id
        LEFT JOIN dim_positions pos ON e.position_id = pos.position_id
        LEFT JOIN dim_directorates dir ON e.directorate_id = dir.directorate_id
        LEFT JOIN dim_grades gr ON e.grade_id = gr.grade_id
        WHERE p.rating = 5
            AND p.year = (SELECT MAX(year) FROM performance_yearly)
        ORDER BY e.fullname
        """
        return self.execute_query(query)

    def insert_vacancy(
        self,
        role_name: str,
        job_level: str,
        role_purpose: str,
        selected_talent_ids: List[str],
        weights_config: Optional[Dict] = None
    ) -> int:
        """Insert new job vacancy and return job_vacancy_id"""

        conn = self.get_connection()
        try:
            with conn.cursor() as cur:
                query = """
                INSERT INTO talent_benchmarks
                (role_name, job_level, role_purpose, selected_talent_ids, weights_config)
                VALUES (%s, %s, %s, %s, %s)
                RETURNING job_vacancy_id
                """

                weights_json = Json(weights_config) if weights_config else None

                cur.execute(query, (
                    role_name,
                    job_level,
                    role_purpose,
                    selected_talent_ids,
                    weights_json
                ))

                vacancy_id = cur.fetchone()[0]
                conn.commit()

                return vacancy_id

        except Exception as e:
            conn.rollback()
            raise e
        finally:
            conn.close()

    # ========================================
    # MATCHING QUERIES
    # ========================================

    def run_matching_query(self, job_vacancy_id: int) -> pd.DataFrame:
        """
        Run the complete matching SQL logic
        Returns detailed TV-level results

        IMPORTANT: This uses your EXACT SQL from document 5
        All temp tables are created and populated dynamically
        """

        conn = self.get_connection()

        try:
            with conn.cursor() as cur:
                # Drop existing temp tables for this vacancy
                cur.execute("DROP TABLE IF EXISTS tb_vacancy CASCADE")
                cur.execute("DROP TABLE IF EXISTS tb_latest_year CASCADE")
                cur.execute("DROP TABLE IF EXISTS tb_selected_talents CASCADE")
                cur.execute("DROP TABLE IF EXISTS tb_profiles_psych_norm CASCADE")
                cur.execute("DROP TABLE IF EXISTS tb_tv_scores_long CASCADE")
                cur.execute("DROP TABLE IF EXISTS tb_baseline_per_tv CASCADE")
                cur.execute("DROP TABLE IF EXISTS tb_employees_with_tv CASCADE")
                cur.execute("DROP TABLE IF EXISTS tb_tv_match_calc CASCADE")
                cur.execute("DROP TABLE IF EXISTS tb_tv_match_with_weights CASCADE")
                cur.execute("DROP TABLE IF EXISTS tb_tgv_aggregation CASCADE")
                cur.execute("DROP TABLE IF EXISTS tb_tgv_with_weights CASCADE")
                cur.execute("DROP TABLE IF EXISTS tb_final_aggregation CASCADE")

                # 1) Create vacancy table
                cur.execute(f"""
                CREATE TABLE tb_vacancy AS
                SELECT
                  j.job_vacancy_id,
                  j.role_name,
                  j.job_level,
                  j.role_purpose,
                  j.selected_talent_ids,
                  j.weights_config
                FROM talent_benchmarks j
                WHERE j.job_vacancy_id = {job_vacancy_id}
                """)

                # 2) Latest year
                cur.execute("""
                CREATE TABLE tb_latest_year AS
                SELECT MAX(year) AS max_year
                FROM competencies_yearly
                """)

                # 3) Selected talents
                cur.execute("""
                CREATE TABLE tb_selected_talents AS
                SELECT v.job_vacancy_id,
                       unnest(v.selected_talent_ids) AS employee_id,
                       v.weights_config
                FROM tb_vacancy v
                """)

                # 4) Profiles psych norm
                cur.execute("""
                CREATE TABLE tb_profiles_psych_norm AS
                SELECT
                  employee_id,
                  iq,
                  gtq,
                  faxtor, pauli, tiki
                FROM profiles_psych
                """)

                # 5) TV scores long - YOUR COMPLETE UNION ALL QUERY
                cur.execute("""
                CREATE TABLE tb_tv_scores_long AS
                SELECT employee_id,
                       'cognitive_ability'::text AS tgv_name,
                       'iq'::text AS tv_name,
                       (iq::text)::numeric AS tv_score,
                       'higher_better'::text AS scoring_direction
                FROM tb_profiles_psych_norm
                WHERE iq IS NOT NULL
                  AND trim(coalesce(iq::text,'')) <> ''
                  AND (iq::text ~ '^\s*[-+]?\d+(\.\d+)?\s*$')

                UNION ALL
                SELECT employee_id, 'cognitive_ability', 'gtq', (gtq::text)::numeric, 'higher_better'
                FROM tb_profiles_psych_norm
                WHERE gtq IS NOT NULL AND trim(coalesce(gtq::text,'')) <> ''
                  AND (gtq::text ~ '^\s*[-+]?\d+(\.\d+)?\s*$')

                UNION ALL
                SELECT employee_id, 'attention_processing', 'faxtor', (faxtor::text)::numeric, 'higher_better'
                FROM tb_profiles_psych_norm
                WHERE faxtor IS NOT NULL AND trim(coalesce(faxtor::text,'')) <> ''
                  AND (faxtor::text ~ '^\s*[-+]?\d+(\.\d+)?\s*$')

                UNION ALL
                SELECT employee_id, 'attention_processing', 'pauli', (pauli::text)::numeric, 'higher_better'
                FROM tb_profiles_psych_norm
                WHERE pauli IS NOT NULL AND trim(coalesce(pauli::text,'')) <> ''
                  AND (pauli::text ~ '^\s*[-+]?\d+(\.\d+)?\s*$')

                UNION ALL
                SELECT employee_id, 'attention_processing', 'tiki', (tiki::text)::numeric, 'higher_better'
                FROM tb_profiles_psych_norm
                WHERE tiki IS NOT NULL AND trim(coalesce(tiki::text,'')) <> ''
                  AND (tiki::text ~ '^\s*[-+]?\d+(\.\d+)?\s*$')

                UNION ALL
                SELECT c.employee_id, 'leadership_competencies', 'gdr', (c.score::text)::numeric, 'higher_better'
                FROM competencies_yearly c, tb_latest_year ly
                WHERE c.pillar_code = 'GDR' AND c.year = ly.max_year
                  AND c.score IS NOT NULL AND trim(coalesce(c.score::text,'')) <> ''
                  AND (c.score::text ~ '^\s*[-+]?\d+(\.\d+)?\s*$')

                UNION ALL
                SELECT c.employee_id, 'leadership_competencies', 'cex', (c.score::text)::numeric, 'higher_better'
                FROM competencies_yearly c, tb_latest_year ly
                WHERE c.pillar_code = 'CEX' AND c.year = ly.max_year
                  AND c.score IS NOT NULL AND trim(coalesce(c.score::text,'')) <> ''
                  AND (c.score::text ~ '^\s*[-+]?\d+(\.\d+)?\s*$')

                UNION ALL
                SELECT c.employee_id, 'leadership_competencies', 'ids', (c.score::text)::numeric, 'higher_better'
                FROM competencies_yearly c, tb_latest_year ly
                WHERE c.pillar_code = 'IDS' AND c.year = ly.max_year
                  AND c.score IS NOT NULL AND trim(coalesce(c.score::text,'')) <> ''
                  AND (c.score::text ~ '^\s*[-+]?\d+(\.\d+)?\s*$')

                UNION ALL
                SELECT c.employee_id, 'execution_competencies', 'qdd', (c.score::text)::numeric, 'higher_better'
                FROM competencies_yearly c, tb_latest_year ly
                WHERE c.pillar_code = 'QDD' AND c.year = ly.max_year
                  AND c.score IS NOT NULL AND trim(coalesce(c.score::text,'')) <> ''
                  AND (c.score::text ~ '^\s*[-+]?\d+(\.\d+)?\s*$')

                UNION ALL
                SELECT c.employee_id, 'execution_competencies', 'sto', (c.score::text)::numeric, 'higher_better'
                FROM competencies_yearly c, tb_latest_year ly
                WHERE c.pillar_code = 'STO' AND c.year = ly.max_year
                  AND c.score IS NOT NULL AND trim(coalesce(c.score::text,'')) <> ''
                  AND (c.score::text ~ '^\s*[-+]?\d+(\.\d+)?\s*$')

                UNION ALL
                SELECT c.employee_id, 'execution_competencies', 'ftc', (c.score::text)::numeric, 'higher_better'
                FROM competencies_yearly c, tb_latest_year ly
                WHERE c.pillar_code = 'FTC' AND c.year = ly.max_year
                  AND c.score IS NOT NULL AND trim(coalesce(c.score::text,'')) <> ''
                  AND (c.score::text ~ '^\s*[-+]?\d+(\.\d+)?\s*$')

                UNION ALL
                SELECT c.employee_id, 'interpersonal_skills', 'sea', (c.score::text)::numeric, 'higher_better'
                FROM competencies_yearly c, tb_latest_year ly
                WHERE c.pillar_code = 'SEA' AND c.year = ly.max_year
                  AND c.score IS NOT NULL AND trim(coalesce(c.score::text,'')) <> ''
                  AND (c.score::text ~ '^\s*[-+]?\d+(\.\d+)?\s*$')

                UNION ALL
                SELECT c.employee_id, 'interpersonal_skills', 'lie', (c.score::text)::numeric, 'higher_better'
                FROM competencies_yearly c, tb_latest_year ly
                WHERE c.pillar_code = 'LIE' AND c.year = ly.max_year
                  AND c.score IS NOT NULL AND trim(coalesce(c.score::text,'')) <> ''
                  AND (c.score::text ~ '^\s*[-+]?\d+(\.\d+)?\s*$')

                UNION ALL
                SELECT c.employee_id, 'interpersonal_skills', 'csi', (c.score::text)::numeric, 'higher_better'
                FROM competencies_yearly c, tb_latest_year ly
                WHERE c.pillar_code = 'CSI' AND c.year = ly.max_year
                  AND c.score IS NOT NULL AND trim(coalesce(c.score::text,'')) <> ''
                  AND (c.score::text ~ '^\s*[-+]?\d+(\.\d+)?\s*$')

                UNION ALL
                SELECT ps.employee_id, 'work_preferences', ('papi_' || lower(ps.scale_code))::text,
                       (ps.score::text)::numeric,
                       CASE WHEN ps.scale_code IN ('Z','K') THEN 'lower_better' ELSE 'higher_better' END
                FROM papi_scores ps
                WHERE ps.score IS NOT NULL AND trim(coalesce(ps.score::text, '')) <> ''
                  AND (ps.score::text ~ '^\s*[-+]?\d+(\.\d+)?\s*$')

                UNION ALL
                SELECT e.employee_id, 'experience', 'years_of_service_months',
                       (e.years_of_service_months::text)::numeric, 'higher_better'
                FROM employees e
                WHERE e.years_of_service_months IS NOT NULL
                  AND trim(coalesce(e.years_of_service_months::text, '')) <> ''
                  AND (e.years_of_service_months::text ~ '^\s*[-+]?\d+(\.\d+)?\s*$')
                """)

                # 6) Baseline per TV
                cur.execute("""
                CREATE TABLE tb_baseline_per_tv AS
                SELECT
                  st.job_vacancy_id,
                  tv.tgv_name,
                  tv.tv_name,
                  tv.scoring_direction,
                  PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY tv.tv_score) AS baseline_score,
                  COUNT(DISTINCT tv.employee_id) AS benchmark_count
                FROM tb_selected_talents st
                JOIN tb_tv_scores_long tv ON tv.employee_id = st.employee_id
                GROUP BY st.job_vacancy_id, tv.tgv_name, tv.tv_name, tv.scoring_direction
                """)

                # 7) Employees with TV
                cur.execute("""
                CREATE TABLE tb_employees_with_tv AS
                SELECT
                  e.employee_id,
                  e.fullname,
                  dir.name AS directorate,
                  pos.name AS role,
                  gr.name AS grade,
                  tv.tgv_name,
                  tv.tv_name,
                  tv.tv_score AS user_score,
                  tv.scoring_direction,
                  b.baseline_score,
                  v.weights_config,
                  v.job_vacancy_id
                FROM employees e
                LEFT JOIN dim_directorates dir ON e.directorate_id = dir.directorate_id
                LEFT JOIN dim_positions pos ON e.position_id = pos.position_id
                LEFT JOIN dim_grades gr ON e.grade_id = gr.grade_id
                CROSS JOIN tb_vacancy v
                LEFT JOIN tb_tv_scores_long tv ON tv.employee_id = e.employee_id
                LEFT JOIN tb_baseline_per_tv b
                  ON b.job_vacancy_id = v.job_vacancy_id
                  AND b.tgv_name = tv.tgv_name
                  AND b.tv_name = tv.tv_name
                WHERE tv.tv_score IS NOT NULL
                """)

                # 8) TV Match Calculation
                cur.execute("""
                CREATE TABLE tb_tv_match_calc AS
                SELECT
                  e.*,
                  CASE
                    WHEN e.baseline_score IS NULL THEN NULL
                    WHEN e.scoring_direction = 'boolean' THEN
                      CASE WHEN e.user_score = e.baseline_score THEN 100.0 ELSE 0.0 END
                    WHEN e.scoring_direction = 'lower_better' THEN
                      CASE
                        WHEN e.baseline_score = 0 OR e.user_score IS NULL THEN NULL
                        ELSE LEAST(GREATEST(((2.0 * e.baseline_score - e.user_score) / NULLIF(e.baseline_score,0)) * 100.0, 0.0), 100.0)
                      END
                    ELSE
                      CASE
                        WHEN e.baseline_score = 0 OR e.user_score IS NULL THEN NULL
                        ELSE LEAST(GREATEST((e.user_score / NULLIF(e.baseline_score,0)) * 100.0, 0.0), 100.0)
                      END
                  END AS tv_match_rate
                FROM tb_employees_with_tv e
                """)

                # 9) TV Match with Weights
                cur.execute("""
                CREATE TABLE tb_tv_match_with_weights AS
                SELECT
                  t.*,
                  CASE
                    WHEN t.weights_config IS NULL THEN 1.0
                    WHEN (t.weights_config #>> ARRAY['TV_weights', t.tgv_name, t.tv_name]) ~ '^\s*[-+]?\d+(\.\d+)?\s*$'
                      THEN (t.weights_config #>> ARRAY['TV_weights', t.tgv_name, t.tv_name])::numeric
                    ELSE 1.0
                  END AS tv_weight
                FROM tb_tv_match_calc t
                """)

                # 10) TGV Aggregation
                cur.execute("""
                CREATE TABLE tb_tgv_aggregation AS
                SELECT
                  employee_id,
                  fullname,
                  directorate,
                  role,
                  grade,
                  tgv_name,
                  CASE
                    WHEN SUM(tv_weight) FILTER (WHERE tv_match_rate IS NOT NULL) = 0 THEN NULL
                    ELSE SUM(tv_match_rate * tv_weight) FILTER (WHERE tv_match_rate IS NOT NULL)
                         / NULLIF(SUM(tv_weight) FILTER (WHERE tv_match_rate IS NOT NULL), 0)
                  END AS tgv_match_rate,
                  COUNT(*) FILTER (WHERE tv_match_rate IS NOT NULL) AS tv_count_with_baseline,
                  MIN(weights_config::text)::jsonb AS weights_config
                FROM tb_tv_match_with_weights
                GROUP BY employee_id, fullname, directorate, role, grade, tgv_name
                """)

                # 11) TGV with Weights
                cur.execute("""
                CREATE TABLE tb_tgv_with_weights AS
                SELECT
                  t.*,
                  CASE
                    WHEN t.weights_config IS NULL THEN
                      CASE t.tgv_name
                        WHEN 'interpersonal_skills' THEN 0.612
                        WHEN 'leadership_competencies' THEN 0.314
                        WHEN 'execution_competencies' THEN 0.041
                        WHEN 'attention_processing' THEN 0.016
                        WHEN 'cognitive_ability' THEN 0.009
                        WHEN 'experience' THEN 0.005
                        WHEN 'work_preferences' THEN 0.003
                        ELSE 1.0 / 7.0
                      END
                    WHEN (t.weights_config #>> ARRAY['TGV_weights', t.tgv_name]) ~ '^\s*[-+]?\d+(\.\d+)?\s*$'
                      THEN (t.weights_config #>> ARRAY['TGV_weights', t.tgv_name])::numeric
                    ELSE
                      CASE t.tgv_name
                        WHEN 'interpersonal_skills' THEN 0.612
                        WHEN 'leadership_competencies' THEN 0.314
                        WHEN 'execution_competencies' THEN 0.041
                        WHEN 'attention_processing' THEN 0.016
                        WHEN 'cognitive_ability' THEN 0.009
                        WHEN 'experience' THEN 0.005
                        WHEN 'work_preferences' THEN 0.003
                        ELSE 1.0 / 7.0
                      END
                  END AS tgv_weight
                FROM tb_tgv_aggregation t
                """)

                # 12) Final Aggregation
                cur.execute("""
                CREATE TABLE tb_final_aggregation AS
                SELECT
                  employee_id,
                  fullname,
                  directorate,
                  role,
                  grade,
                  CASE
                    WHEN SUM(tgv_weight) FILTER (WHERE tgv_match_rate IS NOT NULL) = 0 THEN NULL
                    ELSE SUM(tgv_match_rate * tgv_weight) FILTER (WHERE tgv_match_rate IS NOT NULL)
                         / NULLIF(SUM(tgv_weight) FILTER (WHERE tgv_match_rate IS NOT NULL), 0)
                  END AS final_match_rate,
                  SUM(CASE WHEN tgv_match_rate IS NOT NULL THEN 1 ELSE 0 END) AS tgv_count_with_baseline
                FROM tb_tgv_with_weights
                GROUP BY employee_id, fullname, directorate, role, grade
                """)

                # Final SELECT - Get detailed results
                query_results = """
                SELECT
                  tm.employee_id,
                  tm.fullname,
                  tm.directorate,
                  tm.role,
                  tm.grade,
                  tm.tgv_name,
                  tm.tv_name,
                  ROUND(tm.baseline_score::numeric, 2) AS baseline_score,
                  ROUND(tm.user_score::numeric, 2) AS user_score,
                  ROUND(tm.tv_match_rate::numeric, 2) AS tv_match_rate,
                  ROUND(tgv.tgv_match_rate::numeric, 4) AS tgv_match_rate,
                  ROUND(fa.final_match_rate::numeric, 4) AS final_match_rate
                FROM tb_tv_match_calc tm
                LEFT JOIN tb_tgv_with_weights tgv
                  ON tgv.employee_id = tm.employee_id AND tgv.tgv_name = tm.tgv_name
                LEFT JOIN tb_final_aggregation fa ON fa.employee_id = tm.employee_id
                WHERE tm.baseline_score IS NOT NULL
                ORDER BY fa.final_match_rate DESC NULLS LAST, tm.employee_id, tm.tgv_name, tm.tv_name
                """

                results_df = pd.read_sql_query(query_results, conn)

                return results_df

        except Exception as e:
            conn.rollback()
            raise e
        finally:
            conn.close()

    def get_summary_results(self, job_vacancy_id: int, limit: int = 50) -> pd.DataFrame:
        """Get summary results (top candidates only)"""
        query = f"""
        SELECT
          fa.employee_id,
          fa.fullname,
          fa.directorate,
          fa.role,
          fa.grade,
          ROUND(fa.final_match_rate::numeric, 2) AS final_match_rate_percentage,
          fa.tgv_count_with_baseline
        FROM tb_final_aggregation fa
        WHERE fa.final_match_rate IS NOT NULL
        ORDER BY fa.final_match_rate DESC
        LIMIT {limit}
        """
        return self.execute_query(query)

    def get_vacancy_info(self, job_vacancy_id: int) -> Dict:
        """Get vacancy information"""
        query = f"""
        SELECT * FROM talent_benchmarks
        WHERE job_vacancy_id = {job_vacancy_id}
        """
        result = self.execute_query(query)

        if not result.empty:
            return result.iloc[0].to_dict()
        return {}
# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11VB4ewr_FuogLrsWftnjbRJKJ4MUpSPB
"""

"""
Visualization utilities for Talent Match Dashboard
Creates interactive charts using Plotly

Data expectations:
- summary_df: dataframe returned by DatabaseManager.get_summary_results
    required columns: ['employee_id', 'fullname', 'final_match_rate_percentage', 'tgv_count_with_baseline', ...]
    final_match_rate_percentage expected in percent scale (0-100). If it's in 0-1 scale, code will auto-scale.
- results_df: detailed TV-level results returned by DatabaseManager.run_matching_query
    required columns: ['employee_id','fullname','tgv_name','tv_name','baseline_score','user_score','tv_match_rate','tgv_match_rate','final_match_rate']
    tv_match_rate/tgv_match_rate/final_match_rate expected in percent scale (0-100). If in 0-1, code will auto-scale.
"""

import plotly.graph_objects as go
import plotly.express as px
import pandas as pd
import numpy as np
from typing import List, Optional


def _ensure_percent_scale(s: pd.Series) -> pd.Series:
    """
    Ensure series is on 0-100 percent scale.
    If values appear to be in 0-1 range (max <= 1.0), multiply by 100.
    """
    if s is None or s.empty:
        return s
    try:
        maxv = float(np.nanmax(s.values.astype(float)))
    except Exception:
        # if can't convert, return original
        return s
    if maxv <= 1.0:
        return s.astype(float) * 100.0
    return s.astype(float)


def plot_match_distribution(summary_df: pd.DataFrame) -> go.Figure:
    """
    Plot distribution of match scores across all candidates

    Args:
        summary_df: Summary dataframe with final_match_rate_percentage column

    Returns:
        Plotly figure object
    """

    fig = go.Figure()

    # Defensive: check column
    if 'final_match_rate_percentage' not in summary_df.columns:
        raise ValueError("summary_df must contain column 'final_match_rate_percentage'")

    # Ensure percent scale
    x_series = _ensure_percent_scale(summary_df['final_match_rate_percentage'])

    # Histogram
    fig.add_trace(go.Histogram(
        x=x_series,
        nbinsx=20,
        name='Count',
        marker_color='#1f77b4',
        opacity=0.7,
        hovertemplate='Match Rate: %{x:.1f}%<br>Count: %{y}<extra></extra>'
    ))

    # Add mean line
    mean_val = float(x_series.mean()) if not x_series.empty else 0.0
    fig.add_vline(
        x=mean_val,
        line_dash="dash",
        line_color="red",
        annotation_text=f"Mean: {mean_val:.1f}%",
        annotation_position="top"
    )

    # Add threshold lines
    fig.add_vline(x=70, line_dash="dot", line_color="green", opacity=0.5)
    fig.add_vline(x=80, line_dash="dot", line_color="darkgreen", opacity=0.5)

    fig.update_layout(
        title="Match Score Distribution",
        xaxis_title="Match Rate (%)",
        yaxis_title="Number of Candidates",
        showlegend=False,
        height=400,
        template="plotly_white"
    )

    return fig


def plot_top_candidates(summary_df: pd.DataFrame, top_n: int = 10) -> go.Figure:
    """
    Plot top N candidates as horizontal bar chart

    Args:
        summary_df: Summary dataframe with 'final_match_rate_percentage' and 'fullname'
        top_n: Number of top candidates to show

    Returns:
        Plotly figure object
    """

    # Defensive checks
    for col in ['final_match_rate_percentage', 'fullname', 'employee_id']:
        if col not in summary_df.columns:
            raise ValueError(f"summary_df must contain column '{col}'")

    df = summary_df.copy()

    # Ensure percent scale
    df['final_match_rate_percentage'] = _ensure_percent_scale(df['final_match_rate_percentage'])

    # Get top N
    top_df = df.nlargest(top_n, 'final_match_rate_percentage').copy()
    top_df = top_df.sort_values('final_match_rate_percentage', ascending=True)  # ascending for horizontal bar

    # Create labels: show name + role (if exists) + formatted percent
    def _label(row):
        name = row.get('fullname', '')
        role = row.get('role', None)
        pct = row.get('final_match_rate_percentage', np.nan)
        if pd.notna(role):
            return f"{name} — {role} ({pct:.1f}%)"
        return f"{name} ({pct:.1f}%)"

    top_df['label'] = top_df.apply(_label, axis=1)

    fig = go.Figure()

    fig.add_trace(go.Bar(
        x=top_df['final_match_rate_percentage'],
        y=top_df['label'],
        orientation='h',
        text=top_df['final_match_rate_percentage'].apply(lambda x: f"{x:.1f}%"),
        textposition='outside',
        marker=dict(
            color=top_df['final_match_rate_percentage'],
            colorscale='Blues',
            colorbar=dict(title="Match %", thickness=8),
            reversescale=False
        ),
        hovertemplate="<b>%{y}</b><br>Match: %{x:.1f}%<extra></extra>"
    ))

    fig.update_layout(
        title=f"Top {len(top_df)} Candidates",
        xaxis_title="Match Rate (%)",
        yaxis_title="Candidate",
        height=400 + 30 * min(len(top_df), top_n),
        template="plotly_white",
        margin=dict(l=220 if len(top_df)>6 else 120, r=40, t=60, b=40)
    )

    return fig


def plot_tgv_radar(results_df: pd.DataFrame, employee_id: str) -> go.Figure:
    """
    Radar chart showing TGV-level (Talent Group Variable) match rates for a single employee.

    Args:
        results_df: detailed TV-level results (results of run_matching_query)
        employee_id: id of the employee to plot

    Returns:
        Plotly figure object (radar)
    """

    # Defensive checks
    if results_df is None or results_df.empty:
        raise ValueError("results_df is empty or None")

    if 'employee_id' not in results_df.columns or 'tgv_name' not in results_df.columns or 'tgv_match_rate' not in results_df.columns:
        raise ValueError("results_df must contain 'employee_id', 'tgv_name', and 'tgv_match_rate' columns")

    # Filter employee
    emp_df = results_df[results_df['employee_id'] == employee_id].copy()
    if emp_df.empty:
        raise ValueError(f"No rows for employee_id={employee_id} in results_df")

    # Aggregate tgv_match_rate per tgv_name (there may be duplicates)
    tgv_df = emp_df.groupby('tgv_name', as_index=False)['tgv_match_rate'].max()

    # Ensure percent scale
    tgv_df['tgv_match_rate'] = _ensure_percent_scale(tgv_df['tgv_match_rate'])

    # Sort for consistent order
    tgv_df = tgv_df.sort_values('tgv_match_rate', ascending=False)

    categories = tgv_df['tgv_name'].tolist()
    values = tgv_df['tgv_match_rate'].tolist()

    # Radar requires closed loop
    if len(categories) == 1:
        # if only one category, duplicate to show something meaningful
        categories = categories * 2
        values = values * 2
    else:
        categories = categories + [categories[0]]
        values = values + [values[0]]

    fig = go.Figure()

    fig.add_trace(go.Scatterpolar(
        r=values,
        theta=categories,
        fill='toself',
        name=str(employee_id),
        hovertemplate="%{theta}: %{r:.1f}%<extra></extra>"
    ))

    fig.update_layout(
        polar=dict(
            radialaxis=dict(
                visible=True,
                range=[0, max(100, max(values) if values else 100)]
            )
        ),
        showlegend=False,
        title=f"TGV Radar Profile — Employee {employee_id}",
        template="plotly_white",
        height=480
    )

    return fig


def plot_tv_heatmap(results_df: pd.DataFrame, employee_id: str, top_tgv_count: int = 4) -> go.Figure:
    """
    Heatmap of TV (rows) vs TGV (columns) showing tv_match_rate for a given employee.
    Optionally limits to top N TGVs by tgv_match_rate for clarity.

    Args:
        results_df: detailed results
        employee_id: id
        top_tgv_count: number of top TGVs to include

    Returns:
        Plotly figure object (heatmap)
    """

    # Defensive checks
    required = {'employee_id', 'tgv_name', 'tv_name', 'tv_match_rate'}
    if not required.issubset(set(results_df.columns)):
        raise ValueError(f"results_df must contain columns: {required}")

    emp_df = results_df[results_df['employee_id'] == employee_id].copy()
    if emp_df.empty:
        raise ValueError(f"No rows for employee_id={employee_id} in results_df")

    # Ensure percent scale
    emp_df['tv_match_rate'] = _ensure_percent_scale(emp_df['tv_match_rate'])

    # Choose top TGVs by tgv_match_rate if present, else by mean tv_match_rate
    if 'tgv_match_rate' in emp_df.columns:
        tgv_rank = emp_df.groupby('tgv_name', as_index=False)['tgv_match_rate'].max().sort_values('tgv_match_rate', ascending=False)
    else:
        tgv_rank = emp_df.groupby('tgv_name', as_index=False)['tv_match_rate'].mean().sort_values('tv_match_rate', ascending=False)

    top_tgvs = tgv_rank['tgv_name'].head(top_tgv_count).tolist()

    # Filter to top TGVs
    df_plot = emp_df[emp_df['tgv_name'].isin(top_tgvs)].copy()

    if df_plot.empty:
        raise ValueError("No TV rows after filtering for top TGVs.")

    # Pivot: rows tv_name, cols tgv_name (there could be multiple tv with same name across TGV - uncommon)
    pivot = df_plot.pivot_table(
        index='tv_name',
        columns='tgv_name',
        values='tv_match_rate',
        aggfunc='max'
    ).fillna(np.nan)

    # Sort rows by max match rate descending
    pivot['max_val'] = pivot.max(axis=1)
    pivot = pivot.sort_values('max_val', ascending=False).drop(columns='max_val')

    # Create heatmap
    z = pivot.values
    x = pivot.columns.tolist()
    y = pivot.index.tolist()

    # Create annotations for each cell
    text = [[f"{val:.1f}%" if not pd.isna(val) else "" for val in row] for row in z]

    fig = go.Figure(data=go.Heatmap(
        z=z,
        x=x,
        y=y,
        text=text,
        texttemplate="%{text}",
        hovertemplate="TV: %{y}<br>TGV: %{x}<br>Match: %{z:.1f}%<extra></extra>",
        colorscale='Viridis',
        colorbar=dict(title="Match %")
    ))

    fig.update_layout(
        title=f"TV Match Heatmap — Employee {employee_id} (Top TGVs)",
        xaxis_title="TGV",
        yaxis_title="TV",
        height=500,
        template="plotly_white"
    )

    return fig


def plot_strengths_gaps(results_df: pd.DataFrame, employee_id: str, top_k: int = 10) -> go.Figure:
    """
    Bar chart showing strengths and gaps at TV level for the selected employee.
    Bars sorted by tv_match_rate; colors indicate strength/gap thresholds.

    Args:
        results_df: detailed results
        employee_id: id
        top_k: number of top TV rows to show (both strengths and gaps shown by sorting)

    Returns:
        Plotly Figure
    """

    required = {'employee_id', 'tv_name', 'tgv_name', 'tv_match_rate', 'baseline_score', 'user_score'}
    if not required.intersection(set(results_df.columns)):
        # Not all baseline/user required to show tooltips, but tv_match_rate & tv_name are essential
        if 'tv_match_rate' not in results_df.columns or 'tv_name' not in results_df.columns:
            raise ValueError("results_df must contain at least 'tv_name' and 'tv_match_rate'")

    emp_df = results_df[results_df['employee_id'] == employee_id].copy()
    if emp_df.empty:
        raise ValueError(f"No rows for employee_id={employee_id} in results_df")

    emp_df['tv_match_rate'] = _ensure_percent_scale(emp_df['tv_match_rate'])

    # Aggregate (if duplicates)
    agg = emp_df.groupby(['tgv_name', 'tv_name'], as_index=False).agg({
        'tv_match_rate': 'max',
        'baseline_score': 'max' if 'baseline_score' in emp_df.columns else (lambda x: np.nan),
        'user_score': 'max' if 'user_score' in emp_df.columns else (lambda x: np.nan)
    })

    # Sort descending and take top_k (strengths) and bottom_k (gaps) or show all sorted
    agg_sorted = agg.sort_values('tv_match_rate', ascending=False)
    display_df = agg_sorted.head(top_k).append(agg_sorted.tail(top_k)).drop_duplicates().reset_index(drop=True)

    # For visualization sort by tv_match_rate
    display_df = display_df.sort_values('tv_match_rate', ascending=True)  # ascending so bars left->right show gaps->strengths vertically

    # Color mapping: strong >=80 green, medium 50-80 orange, gap <50 red
    def _color(v):
        if pd.isna(v):
            return '#d3d3d3'
        try:
            v = float(v)
        except Exception:
            return '#d3d3d3'
        if v >= 80:
            return '#2ca02c'  # green
        if v >= 50:
            return '#ff7f0e'  # orange
        return '#d62728'      # red

    colors = [ _color(v) for v in display_df['tv_match_rate'] ]

    hover_text = display_df.apply(
        lambda r: f"TGV: {r['tgv_name']}<br>TV: {r['tv_name']}<br>Match: {r['tv_match_rate']:.1f}%"
                  + (f"<br>User Score: {r['user_score']:.2f}" if pd.notna(r.get('user_score', np.nan)) else "")
                  + (f"<br>Baseline: {r['baseline_score']:.2f}" if pd.notna(r.get('baseline_score', np.nan)) else ""),
        axis=1
    )

    fig = go.Figure(go.Bar(
        x=display_df['tv_match_rate'],
        y=display_df.apply(lambda r: f"{r['tv_name']} — {r['tgv_name']}", axis=1),
        orientation='h',
        marker=dict(color=colors),
        hovertext=hover_text,
        hoverinfo='text',
        text=display_df['tv_match_rate'].apply(lambda x: f"{x:.1f}%"),
        textposition='outside'
    ))

    fig.update_layout(
        title=f"Strengths & Gaps — Employee {employee_id}",
        xaxis_title="TV Match Rate (%)",
        yaxis_title="TV — TGV",
        height=420 + 25 * len(display_df),
        template="plotly_white",
        margin=dict(l=240 if len(display_df) > 8 else 120, r=40, t=60, b=40)
    )

    return fig